# Файлы
# Как работать с файлами:
# Связать файловую переменную с файлом,
# определив модификатор работы
# a – открытие для добавления данных
# r – открытие для чтения данных
# w – открытие для записи данных
# w+, r+

# with open('file.txt', 'w') as data: # В данном случае тоже самое, что и ниже
#  data.write('line 1\n')             # только звучит как в конструкции with
#  data.write('line 2\n')             # взаимодействуем с файлом 'file.txt'
#                                     # методом  'w' и всё эту конструкцию with open('file.txt', 'w')
#                                     # воспринимать как переменную  data (as data).
# # И в такой конструкции не обязательно использовать data.close(), так как автоматически файл закрывается.


# colors = ['red', 'green', 'blue'] # colors - Просто текстовый список. 
# data = open('file.txt', 'a') # data - файловая переменная, open - взаимодействие с файлом 'file.txt'
# # ('file.txt' указывается путь к файлу) методом  'a' (a – открытие для добавления данных)
# 
# data.writelines(colors) # data.writelines(colors) где data - по прежнему файловая переменная.
# # writelines - позволяет записать в data список colors.
# # разделителей не будет
# data.close() # close - Далее необходимо обязательно закрыть файл.
# 
# # # Или так 
# # colors = ['red', 'green', 'blue'] 
# # data = open('file.txt', 'a')
# # data.write('\nLine 2\n') # Добавляем в файл новые данные
# # data.write('Line 3\n')   # На следующие строки.
# # data.close()
# 
# # exit() # exit - после этой команды дальнейшая программа не будет задействована.

# path = 'file.txt' # Создали строковую переменную.
# data = open(path, 'r') # Создали файловую переменную и
# # преобразовали строковую переменную во взаимодействие open(path, 'r')
# # где r – открытие для чтения данных
# for line in data: # Создали цикл где line будет пробегать по строкам в переменной data
#     # и выводить их.
#     print(line)
# data.close() # Закрыли файл.




# Функции.

# def f(x):
#     return x**2
# def f(x):
#     if x == 1:
#         return 'Целое'            # Эта функции записана в файле Hello, а тут указана для наглядности. 
#     elif x == 2.3:
#         return 23
#     else:
#         return

# print(f(1)) # Целое
# print(f(2.3)) # 23
# print(f(28)) # None               # Эта функции записана в файле Hello, а тут указана для наглядности. 
# print(type(f(1))) # str
# print(type(f(2.3))) # int
# print(type(f(28))) # NoneType     

import Hello # Импортирую функции из другого файла.

print(Hello.f(1)) # Выводим эту функцию. 

# Или

import Hello as h # Импортирую функции из другого файла, где Hello переименовали в h.

print(h.f(1)) # Выводим эту функцию. 



# Функции.

# def new_string(symbol, count):
#     return symbol * count
# print(new_string('!', 5))   # Можно умножать строки на цифры и будет !!!!!
# print(new_string('!'))      # Будет ошибка так как не указана вторая переменная.

# Но можно было бы так 
def new_string(symbol, count = 3): # Сразу присваиваем 3 к переменной.
    return symbol * count
print(new_string('!', 5))   # Тут по прежнему будет 5.
print(new_string('!'))      # А уже тут будет "!" автоматически умножен на 3.



# Функции.

def concatenatio(*params): # Функция по выводу условна бесконечного количества элементов.
    res: str = ""  # Таким образом мы указали сразу, что переменная res имеет тип данных str и присвоили к res пустую строку "".
    for item in params: # Просто цикл вывода всех заложенных элементов params.
        res += item
    return res
# Не забываем, что это строковая функция.
print(concatenatio('a', 's', 'd', 'w')) # Вводим необходимые данные для вывода в строковом формате.
print(concatenatio('a', '1', 'd', '2')) # Вводим необходимые данные для вывода в строковом формате.
# print(concatenatio(1, 2, 3, 4)) # Будет ошибка так формат указан int а не str.

# Если с int то так:
def concatenatio1(*params1):    # И этой функцией мы складывать числа.
    res1: int = 0 # К переменной присвоили 0
    for item1 in params1: # Переменной item1 проходим по переменной params1 
        res1 += item1 # Складываем числа.
    return res1 
print(concatenatio1(1, 2, 3, 4))




# Рекурсия.


def fib(n):
    if n in [1, 2]: # В промежуток от 1 до 2 включительно возвращаем 1.
        return 1
    else:
        return fib(n-1) + fib(n-2)

list = []
for e in range(1, 10):
    list.append(fib(e))
print(list) # 1 1 2 3 5 8 13 21 34





# Кортежи -  как некий не изменяемый список.

a = (3, 6, 4) # и есть кортеж
print(a)
a = (3, 6, 4)
print(a[0])
a = (3, 6, 4)
print(a[-1]) # Ответ будет последний элемент 4.
# Присваивать элементы к индексам нельзя a[0] = 45

# a = (3) это уже не кортеж, кортеж выглядит так a(3,)



t = ()
print(type(t)) # Показывает тип tuple.
t = (1,)
print(type(t)) # Показывает тип tuple .
t = (1)
print(type(t)) # Показывает тип int.
t = (28, 9, 1990)
print(type(t)) # Показывает тип tuple
colors = ['red', 'green', 'blue']
print(colors) # Вывод ['red', 'green', 'blue']
t = tuple(colors) # Преобразовали список в кортеж.
print(t) # ('red', 'green', 'blue')

t = tuple(['red', 'green', 'blue'])
print(t[0]) # red
print(t[2]) # blue
# print(t[10]) # Ошибка, вышли за предела индекса.
print(t[-2]) # green
# print(t[-200]) # Ошибка, вышли за предела индекса.
for e in t:
    print(e) # Вывод red green blue
# t[0] = 'black' # Ошибка, нельзя присваивать в индексы кортежа.

t = tuple(['red', 'green', 'blue']) # переменную t определили как кортеж одновременно преобразовав из списка.
red, green, blue = t # Создали новые переменные и присвоили им t тем самым определив их как кортежи.
print('r:{} g:{} b:{}'.format(red, green, blue))
# r:red g:green b:blue






# Словари.


dictionary = {} # Создали пустой словарь.
# ОБратный слэш ниже ставим для того, что бы перейти на другой строку и писать там.
dictionary = \
    {
    'up': '↑',   # До знака ":" указываем название элемента словаря (ключи), после знака ":" указываем сам.
    'left': '←', # До знака ":" указываем название элемента словаря (ключи), после знака ":" указываем сам.
    'down': '↓', # До знака ":" указываем название элемента словаря (ключи), после знака ":" указываем сам.
    'right': '→' # До знака ":" указываем название элемента словаря (ключи), после знака ":" указываем сам.
    }
print(dictionary) # {'up':'↑', 'left':'←', 'down':'↓', 'right':'→'} - Выводим весь словарь.
print(dictionary['left']) # ← Выводим только команду left со знаком ←.
# типы ключей могут отличаться

for i in dictionary.keys(): # Данной командой мы выводим все ключи в терминал.
    print(i)
# Или
for i in dictionary.values(): # Данной командой мы выводим все значения в терминал.
    print(i)



print(dictionary['up']) # Выводим ↑
# типы ключей могут отличаться
dictionary['left'] = '⇐' # Можем менять значения путём присваивания к ключу, новое значение.
print(dictionary['left']) # Выводим ⇐
#print(dictionary['type']) # Ошибка, такого ключа нет.
del dictionary['left'] # удаление элемента
for item in dictionary: # Проходим по всему словарю, и выводим ключ значение ключа по порядку.
    print('{}: {}'.format(item, dictionary[item]))
# Вывод:
# up: ↑
# down: ↓
# right: →






# Множества - Неупорядоченная совокупность элементов.
a = {1, 2, 3, 5, 8}
b = {'2', '5', 8, 13, 21}
print(type(a)) # Тип set
print(type(b)) # Тип set


colors = {'red', 'green', 'blue'}
print(colors) # {'red', 'green', 'blue'}
colors.add('red') # Пытаясь добавить такой же элемент ни чего не измениться.
print(colors) # {'red', 'green', 'blue'}
colors.add('gray') # Данным образом добавляем новый элемент в конец множества.
print(colors) # {'red', 'green', 'blue','gray'}
colors.remove('red') # Данным образом удаляем конкретный элемент.
print(colors) # {'green', 'blue','gray'}
# colors.remove('red') # Ошибка, мы пытаемся удалить элемент которого и так нет.
colors.discard('red') # Или удалить так, тогда ошибки не будет и программа будет работать дальше.
print(colors) # {'green', 'blue','gray'}
colors.clear() # { } - Данный командой мы очищаем множество и оно становиться пустым. 
print(colors) # set()


a = {1, 2, 3, 5, 8}
b = set([2, 5, 8, 13, 21]) # Таким образом мы преобразуем списки в множества указав тип set.
c = set((2, 5, 8, 13, 21)) # Таким образом мы преобразуем списки в множества указав тип set.
print(type(a)) # set
print(type(b)) # set
print(type(c)) # set
a = {1, 1, 1, 1, 1}
print(a) # {1}

a = {1, 2, 3, 5, 8}
b = {2, 5, 8, 13, 21}
c = a.copy() # c = {1, 2, 3, 5, 8} т.е. создали ещё одно такое множество под другой переменной.
u = a.union(b) # u = {1, 2, 3, 5, 8, 13, 21} т.е. объединяем 2 множества под новой переменной.
i = a.intersection(b) # i = {8, 2, 5} т.е. объединение множеств только одинаковыми значениями.
dl = a.difference(b) # dl = {1, 3}   т.е. выводим только те значения, который нет в множестве "b" 
dr = b.difference(a) # dr = {13, 21} т.е. выводим только те значения, который нет в множестве "a"
# ОБратный слэш ниже ставим для того, что бы перейти на другой строку и писать там.
q = a \
 .union(b) \
 .difference(a.intersection(b)) # У нас получается такое уравнение из нескольких функций.
# {1, 21, 3, 13}

# Не изменяемое множество.
a = {1, 2, 3, 5, 8}
b = frozenset(a) # Такой функцией мы заморозим множество тем самым после этого уже нельзя его изменять. 
print(b) # frozenset({1, 2, 3, 5, 8})





# Списки.
# Если в одном списке, что то меняешь и до этого просто копир список от другого, то изменения коснуться обоих списков, такая особенность.
List1 = [1,2,3,4,5]
List2 = List1

List1[0] = 123
List2[1] = 333

for d in List1:
    print(d)

print() # Пропустить строку.

for r in List2:
    print(r)

List1.pop() # Данная операция удаляет последний элемент списка.
print(List1)
List1.pop(3) # Данная операция удаляет элемент из списка с индексом 3.
print(List1)
List1.insert(1, 48) # Данная операция добавляет ещё 1 элемент в список, где 1 это номер индекса куда мы добавляем элемент, а 48 сам элемент. 
print(List1) 
print(List2)