# Анонимные, lambda функции

# Примеры:


def mult(x):
    return x**2
print(type(mult)) # Получится тип функции.
g = mult # Это значит, что к новый переменной мы можем присвоить функцию.
         # Но важно не вызывать её при присвоении, т.е. скобки не ставим.
print(mult(2))

# Зачем к переменной присваивать функцию ?:
def sum(x):
    return x+10
print(sum(10))
def sum2(x):
    return x*10
print(sum2(10))
def mach(pop, x): # Т.е. мы создали функцию, которая будет вызывать другие функции.
    print(pop(x)) # Т.е. мы создали функцию, которая будет вызывать другие функции.
mach(sum2, 10)    # Т.е. мы создали функцию, которая будет вызывать другие функции.
mach(sum, 10)     # Т.е. мы создали функцию, которая будет вызывать другие функции.

# Или.

# def result(x, y):         # Функция result и переменная result ниже это одно и то же, т.е. и там и там функция.
#     return x + y          # Функция result и переменная result ниже это одно и то же, т.е. и там и там функция.
result = lambda x, y: x+y   # Функция result и переменная result ниже это одно и то же, т.е. и там и там функция.
# Во всех выводах мы пишем так же result(переменные).
def result2(x, y):
    return x * y
def mach2(op, a, b):
    print(op(a, b))
    return op(a, b)
mach2(result, 5, 5)
mach2(result2, 6, 6)
# Или так.
mach2(lambda x, y: x+y, 5, 5)





#  List Comprehension - нужен, что бы очень быстро создавать списки.


# [exp for item in iterable]
# [exp for item in iterable (if conditional)]
# [exp <if conditional> for item in iterable (if conditional)]
# Примеры:
# Создаём список от 1 до 100 из чётных чисел:
list1 = []
for i in range(1,101):
    if not i % 2:
        list1.append(i)
print(list1)
# Или так.
list1 = [i for i in range(1,101) if not i % 2] # Таким образом мы заполнили список.
print(list)
# Или так но с картежами.
list1 = [(i, i) for i in range(1,101) if not i % 2] # Таким образом мы заполнили список.
print(list1)
# Или так.
# В данном случае мы добавили функцию, которая звучит так:
# С начало мы выставил рэньж range(1,21)
# Дале указали, что работаем только с чётными числами if not i % 2
# Далее эти числа попадают в функцию q(i) и взаимодействуют.
def q(x):
    return x**3
list1 = [q(i) for i in range(1,21) if not i % 2] # Таким образом мы заполнили список.
print(list1)
# Или так же но с картежом.
def q(x):
    return x**3
list1 = [(i, q(i)) for i in range(1,21) if not i % 2] # Таким образом мы заполнили список.
print(list1)



# Задача:
# В файле хранятся числа, нужно выбрать четные и
# составить список пар (число; квадрат числа).
# Пример:
# 1 2 3 5 8 15 23 38
# Получить:
# [(2, 4), (8, 64), (38, 1444)]

# path = 'D:\Zona\Git\Pyton_S_L\Lectures\Lesson_3\qwe.txt' # Присвоили к переменной path путь к файлу.
# s = open(path, 'r')   # Дальше связываем файловую переменную s с файлом на диске open(path, 'r'), где path это файловая переменная а r чтение этого файла.
# data = s.read() + ' ' # Данным способом s.read() + ' ' мы считываем всё, что есть в файле и искусственно добавляем пробел +' '
# s.close()             # Закрываем файл.
# 
# numbers = []
# 
# while data != '': # Пробегаемся по строке data и делаем проверку пока строка не пустая.
#     space_poc = data.index(' ') # Далее к переменной space_poc присваиваем индекс пробела data.index(' ')
#     numbers.append(int(data[:space_poc])) # Далее добавляем в список numbers всё, что находится до индекса пробела [:space_poc]
#     data = data[space_poc+1:] # Обновили строку добавив всё от индекса space_poc+1 до далее data[space_poc+1:].
# 
# out = []
# for e in numbers:
#     if not e % 2:
#         out.append((e, e**2)) # Создали кортежи в списке.
# print(out)
# Делаем код лучше:

def select(t, col):
    return [t(y) for y in col]
def where(t, col):
    return [y for y in col if t(y)]

data1 = '1 2 3 5 8 15 23 38'.split() # Функция split преобразует строку в список где знак в скобках () будет разделителем элементов.
                                     # По умолчанию ставим () что означает разделителем элементов будет пробел.

res = select(int, data1) # Преобразовали список строк в числа методом: Добавили в переменную res функцию select которая указан выше.
# где int в этой функции указывает на число а data на с строковой список, т.е. мы пробегаем переменной y(int) по списку col(data) и 
# какой элемент списка является числом возвращаем.
print(res)
res = where(lambda x: not x % 2, res) # В данном случае мы к res присвоили функцию where, где воспользовались lambda сделали выборку
# not x % 2 чётных чисел из списка res.
print(res)
res = select(lambda x: (x, x**2), res) # В данном случае мы в функции select добавили lambda и получается переменная
# t в функции  select и есть  lambda, а переменная res в функции  select и есть col.
# Отличие от двух универсальных функций select и where тем , что в select с начало стоит t(y) т.е. действие уже 
# работает по всем элементам списка col(res), а в where с начало цикл выборки y по col и выборка if  уже тогда вступает в действие 
# функция lambda.
print(res) # с кортежами (x, x**2).






# Функция map

# Функция map() применяет указанную функцию к
# каждому элементу итерируемого объекта и
# возвращает итератор с новыми объектами.
# f(x) ⇒ x + 10
# map(f, [ 1, 2, 3, 4, 5])
#  ↓ ↓ ↓ ↓ ↓
#  [ 11, 12, 13, 14, 15]
# Нельзя пройтись дважды

li = [z for z in range(1,21)]
print(li)

li = list(map(lambda x: x+10, li)) # Функция
print(li)

data2 = list(map(int, input().split()))
print(data2)

# Таким образом мы можем переделать предыдущую функцию select.

res = map(int, data1) # Таким образом мы избавились от функции select.
print(res)
res = where(lambda x: not x % 2, res) # В данном случае мы к res присвоили функцию where, где воспользовались lambda сделали выборку
# not x % 2 чётных чисел из списка res.
print(res)
res = list(map((lambda x: (x, x**2), res))) 
print(res) # с кортежами (x, x**2).






# Функция filter

# Функция filter() применяет указанную функцию к
# каждому элементу итерируемого объекта и
# возвращает итератор с теми объектами, для
# которых функция вернула True.
# f(x) ⇒ x - чётное
# filter(f, [ 1, 2, 3, 4,5])
#  ↓
#  [ 2, 4 ]
# Нельзя пройтись дважды

data3 = [u for u in range(10)]

res = list(filter(lambda x: not x % 2, data3))
print(res)

res = map(int, data1) # Таким образом мы избавились от функции select.
print(res)
res = filter(lambda x: not x % 2, res) # Таким образом мы избавились от функции select.
print(res)
res = list(map((lambda x: (x, x**2), res))) 
print(res) # с кортежами (x, x**2).









# Функция zip

# Функция zip() применяется к набору итерируемых
# объектов и возвращает итератор с кортежами из
# элементов входных данных.
# Количество элементов в результате равно минимальному количеству элементов входного набора
# zip ([1, 2, 3], [ ‘о‘, ‘д‘, ‘т‘], [‘f’,’s’,’t’])
#  ↓
# [(1, 'о', 'f'), (2, 'д', 's'), (3, 'т', 't')]
# Нельзя пройтись дважды


# Списке объединяются по индексу, т.е. первый индекс к первому, второй ко второму и тд.
user = ['user1', 'user2', 'user3', 'user4', 'user5']
ids = [4,5,9,14,7]
qwerqt = [1,2,3]

data4 = list(zip(user,ids))
print(data4)
# На выходе получаем два объединённых списка user и ids
# В виде кортежей [('user1', 4), ('user2', 5), ('user3', 9,) и тд.]
# Если добавить ещё один список с меньшем количеством переменных, то длинна нового соединяющего списка 
# будет равна длине самого короткого списка.



def sum1(x):
    return x+22
def mult2(x):
    return x**3
sum1(mult2(2))

def sum3(x):
    return x+242
def mult4(x):
    return x**5
sum3(mult2(2))



